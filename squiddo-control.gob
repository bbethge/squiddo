%h{
#include <gtk/gtk.h>

struct _SquiddoBox;
%}

%{
#include <math.h>
#include <string.h>
#include <gdk/gdk.h>
#include <cairo.h>

#define SPEED_X 0.04
#define SPEED_Y 0.07
#define BOX_ASPECT 2.0

typedef struct _SquiddoBox Box;
struct _SquiddoBox {
	GtkWidget *owner;
	gchar *path;
	gchar *collation_key;
	PangoLayout *label;
	gboolean items_loaded;
	guint n_items;
	struct _SquiddoBox **items;
};
%}

class Squiddo:Control from Gtk:Widget {

protected gboolean active = FALSE;
protected Gdk:Cursor *null_cursor = NULL unrefwith gdk_cursor_unref;
protected struct _SquiddoBox *box = NULL unrefwith self_box_destroy;
protected double y = 0.0;
protected double log_scale = 0.0;

init(self) {
	GtkWidget *wid = GTK_WIDGET(self);
	/* Create a cursor with no pixels in it */
	const char zero = 0;
	GdkPixmap *pm = gdk_bitmap_create_from_data(NULL, &zero, 1, 1);
	GdkColor dummy_color = { 0, };
	self->null_cursor = gdk_cursor_new_from_pixmap(
		pm, pm, &dummy_color, &dummy_color, 0, 0
	);
	g_object_unref(G_OBJECT(pm));
	self->box = self_box_new(GTK_WIDGET(self), "/");
	/* Just to make sure -- we want a window. */
	GTK_WIDGET_UNSET_FLAGS(wid, GTK_NO_WINDOW);
}

public Gtk:Widget *new(void) {
	Self *ret = GET_NEW;
	return GTK_WIDGET(ret);
}

override (Gtk:Widget) void realize(Gtk:Widget *self) {
	GdkWindowAttr win_attr;
	GTK_WIDGET_SET_FLAGS(self, GTK_REALIZED);
	win_attr.window_type = GDK_WINDOW_CHILD;
	win_attr.x = self->allocation.x;
	win_attr.y = self->allocation.y;
	win_attr.width = self->allocation.width;
	win_attr.height = self->allocation.height;
	win_attr.wclass = GDK_INPUT_OUTPUT;
	win_attr.event_mask = gtk_widget_get_events(self);
	win_attr.event_mask |= GDK_POINTER_MOTION_MASK | GDK_EXPOSURE_MASK |
		GDK_BUTTON_PRESS_MASK;
	self->window = gdk_window_new(
		gtk_widget_get_parent_window(self),
		&win_attr, GDK_WA_X | GDK_WA_Y
	);
	gdk_window_set_user_data(self->window, self);
	self->style = gtk_style_attach(self->style, self->window);
}

override (Gtk:Widget) gboolean expose_event(
	Gtk:Widget *self (check null type), Gdk:Event:Expose *event
) {
	gint width = self->allocation.width;
	gint height = self->allocation.height;
	gint x, y;
	gint box_height;
	/* Draw the background */
	gdk_draw_rectangle(
		self->window, self->style->bg_gc[GTK_WIDGET_STATE(self)],
		TRUE, 0, 0, width, height
	);
	/* Draw boxes */
	box_height = (gint)(height*exp(SELF(self)->log_scale));
	gdk_draw_rectangle(
		self->window, self->style->fg_gc[GTK_WIDGET_STATE(self)],
		FALSE, width - BOX_ASPECT*box_height, SELF(self)->y,
		BOX_ASPECT*box_height, box_height
	);
	self_box_draw(
		SELF(self)->box, &event->area, SELF(self)->y,
		box_height, width, height
	);
	/* Draw the rubber arrow */
	if(SELF(self)->active) {
		gtk_widget_get_pointer(self, &x, &y);
		self_draw_arrow(self, &event->area, width/2, height/2, x, y);
	}
	return TRUE;
}

private void draw_arrow(
	Gtk:Widget *self, Gdk:Rectangle *area,
	gint x1, gint y1, gint x2, gint y2
) {
	cairo_t *cr = gdk_cairo_create(self->window);
	if(area) {
		gdk_cairo_rectangle(cr, area);
		cairo_clip(cr);
	}
	gdk_cairo_set_source_color(
		cr, &self->style->fg[GTK_WIDGET_STATE(self)]
	);
	cairo_move_to(cr, x1, y1);
	cairo_line_to(cr, x2, y2);
	cairo_translate(cr, x2, y2);
	cairo_rotate(cr, atan2(y2 - y1, x2 - x1));
	cairo_move_to(cr, -8.0, 5.0);
	cairo_line_to(cr, 0.0, 0.0);
	cairo_line_to(cr, -8.0, -5.0);
	cairo_stroke(cr);
	cairo_destroy(cr);
}

override (Gtk:Widget) gboolean button_press_event(
	Gtk:Widget *self (check null type), Gdk:Event:Button *event (check null)
) {
	if(event->type == GDK_BUTTON_PRESS && event->button == 1) {
		SELF(self)->active = !SELF(self)->active;
		if(SELF(self)->active) {
			gdk_pointer_grab(
				self->window, FALSE,
				GDK_POINTER_MOTION_MASK | GDK_BUTTON_PRESS_MASK,
				self->window, SELF(self)->null_cursor,
				event->time
			);
			g_timeout_add(30, (GSourceFunc)self_update, SELF(self));
		} else {
			gdk_pointer_ungrab(event->time);
		}
		gtk_widget_queue_draw(self);
	}
	return PARENT_HANDLER(self, event);
}

override (Gtk:Widget) gboolean motion_notify_event(
	Gtk:Widget *self (check null type), Gdk:Event:Motion *event
) {
	if(SELF(self)->active) gtk_widget_queue_draw(self);
	return PARENT_HANDLER(self, event);
}

override (Gtk:Widget) void style_set(
	Gtk:Widget *self (check null type), Gtk:Style *prev_style
) {
	PARENT_HANDLER(self, prev_style);
	if(SELF(self)->box != NULL) {
		self_box_update_pango_context(SELF(self)->box);
	}
}

override (Gtk:Widget) void direction_changed(
	Gtk:Widget *self (check null type), GtkTextDirection prev_direction
) {
	PARENT_HANDLER(self, prev_direction);
	if(SELF(self)->box != NULL) {
		self_box_update_pango_context(SELF(self)->box);
	}
}

private gboolean update(self) {
	gint x, y;
	gint width = GTK_WIDGET(self)->allocation.width;
	gint height = GTK_WIDGET(self)->allocation.height;
	double d_log_scale;
	if(!self->active) return FALSE;
	gtk_widget_get_pointer(GTK_WIDGET(self), &x, &y);
	x -= width/2;
	y -= height/2;
	d_log_scale = (double)x/(width/2) * SPEED_X;
	self->log_scale += d_log_scale;
	self->y = height/2 + exp(d_log_scale)*(self->y - height/2)
		- (double)y*SPEED_Y;
	gtk_widget_queue_draw(GTK_WIDGET(self));
	return TRUE;
}

/*
 * Box invariants:
 * (!items_loaded || n_items == 0) <=> items == NULL
 * n_items > 0 => items_loaded
 * owner != NULL
 * path != NULL
 * label != NULL
 */

protected Box *box_new(
	Gtk:Widget *owner (check null), const gchar *path (check null)
) {
	Box *ret = g_new(Box, 1);
	gchar *name;
	ret->owner = owner;
	ret->path = g_strdup(path);
	name = g_path_get_basename(ret->path);
	ret->collation_key = g_utf8_collate_key_for_filename(name, -1);
	ret->label = gtk_widget_create_pango_layout(owner, name);
	g_free(name);
	ret->items_loaded = FALSE;
	ret->items = NULL;
	ret->n_items = 0;
	return ret;
}

protected void box_destroy(Box *box) {
	guint i;
	if(box == NULL) return;
	if(box->label != NULL) g_object_unref(box->label);
	g_free(box->path);
	g_free(box->collation_key);
	if(box->items_loaded && box->items != NULL) {
		for(i = 0; i < box->n_items; i++) {
			self_box_destroy(box->items[i]);
		}
		g_free(box->items);
	}
	g_free(box);
}

protected void box_update_pango_context(Box *box) {
	guint i;
	pango_layout_context_changed(box->label);
	if(!box->items_loaded || box->n_items == 0) return;
	for(i = 0; i < box->n_items; i++) {
		self_box_update_pango_context(box->items[i]);
	}
}

protected gint box_compare_names(
	Box *const *b1, Box *const *b2, gpointer unused
) {
	return strcmp((*b1)->collation_key, (*b2)->collation_key);
}

protected void box_ensure_items_loaded(Box *box) {
	GDir *dir;
	const gchar *name;
	if(box->items_loaded) return;
	box->items_loaded = TRUE;
	dir = g_dir_open(box->path, 0, NULL);
	box->n_items = 0;
	if(dir == NULL) return;
	for(;;) {
		name = g_dir_read_name(dir);
		if(name == NULL) break;
		box->n_items++;
	}
	if(box->n_items > 0) {
		guint i;
		gchar *path;
		g_dir_rewind(dir);
		box->items = g_new(Box*, box->n_items);
		for(i = 0; i < box->n_items; i++) {
			name = g_dir_read_name(dir);
			path = g_build_filename(box->path, name, NULL);
			box->items[i] = self_box_new(
				box->owner, path
			);
			g_free(path);
		}
		g_qsort_with_data(
			box->items, box->n_items, sizeof(box->items[0]),
			(GCompareDataFunc)squiddo_control_box_compare_names,
			NULL
		);
	}
	g_dir_close(dir);
}

protected void box_draw(
	Box *box, Gdk:Rectangle *area,
	gint y, guint height, guint win_width, guint win_height
) {
	GtkWidget *owner = box->owner;
	guint width = (guint)(height*BOX_ASPECT);
	int label_height;
	pango_layout_get_pixel_size(box->label, NULL, &label_height);
	gtk_paint_layout(
		owner->style, owner->window, GTK_WIDGET_STATE(owner), TRUE,
		area, owner, NULL, win_width - width,
		y + (height - label_height)/2, box->label
	);
	self_box_ensure_items_loaded(box);
	self_box_draw_items(box, area, y, height, win_width, win_height);
}

protected void box_draw_items(
	Box *box, Gdk:Rectangle *area,
	gint y, guint height, guint win_width, guint win_height
) {
	GtkWidget *owner = box->owner;
	guint n_items = box->n_items;
	double item_height = (double)height/n_items;
	guint item_width = (guint)(item_height*BOX_ASPECT);
	guint i;
	if(height >= 8*n_items) {
		for(i = 0; i < n_items; i++) {
			gint item_y = y + (gint)(i*item_height);
			if(
				item_y >= (gint)win_height ||
				item_y + (gint)item_height < 0
			) continue;
			self_box_draw(
				box->items[i], area, item_y, item_height,
				win_width, win_height
			);
		}
	}
	if(height < 2*n_items) return;
	for(i = 1; i < n_items; i++) {
		gint item_y = (gint)(y + i*item_height);
		gdk_draw_line(
			owner->window,
			owner->style->fg_gc[GTK_WIDGET_STATE(owner)],
			item_width > win_width ? 0 : win_width - item_width,
			item_y, win_width, item_y
		);
	}
}

}
